module main
author unknown
version 1 0 
description ''
variables potentiometer 

script 88 43 {
whenStarted
wifiConnect '--------------------' '----------------------'
comment 'Type the information of your Wi-Fi network in the empty fields.'
waitMillis 500
OLEDInit_I2C 'OLED_0.96in' '3C' 0 false
OLEDwrite ('[data:join]' 'IP: ' (getIPAddress)) 0 0 false
comment '1-RGB LED & OLED Screen
2-Red LED
3-Temp & Hum
4-Role
5-Motor Driver
6-buzzer
7-Potansiyometre'
}

script 622 104 {
whenCondition ((receiveIR) == 69)
OLEDwrite 'Hello PicoBricks' 0 10 false
pb_set_rgb_color (colorSwatch 20 49 190 255)
}

script 1101 132 {
whenCondition ((receiveIR) == 28)
OLEDclear
pb_turn_off_RGB
pb_set_red_LED false
pb_set_motor_speed 1 0
pb_set_motor_speed 2 0
}

script 622 257 {
whenCondition ((receiveIR) == 70)
pb_set_red_LED true
}

script 95 331 {
whenCondition (pb_button)
repeat 5 {
  pb_set_rgb_color (colorSwatch 30 24 190 255)
  waitMillis 50
  pb_set_rgb_color (colorSwatch 190 37 10 255)
  waitMillis 50
  pb_set_rgb_color (colorSwatch 86 190 18 255)
}
pb_turn_off_RGB
}

script 1092 334 {
whenCondition ((pb_light_sensor) < 60)
repeat 5 {
  pb_set_rgb_color (colorSwatch 30 24 190 255)
  waitMillis 50
  pb_set_rgb_color (colorSwatch 190 37 10 255)
  waitMillis 50
  pb_set_rgb_color (colorSwatch 86 190 18 255)
  pb_turn_off_RGB
}
}

script 357 368 {
whenCondition ((receiveIR) == 67)
pb_beep 500
}

script 630 380 {
whenCondition ((receiveIR) == 71)
OLEDwrite 'Temperature: ' 0 20 false
OLEDwrite (pb_temperature) 100 20 false
OLEDwrite 'Humidity: ' 0 30 false
OLEDwrite (pb_humidity) 100 30 false
}

script 96 602 {
whenCondition ((receiveIR) == 7)
forever {
  OLEDwrite 'POT:' 0 40 false
  OLEDwrite ('[misc:rescale]' (pb_potentiometer) 0 1023 0 9) 100 40 false
}
}

script 1099 622 {
whenCondition ((receiveIR) == 64)
pb_set_motor_speed 1 100
pb_set_motor_speed 2 100
}

script 642 626 {
whenCondition ((receiveIR) == 68)
pb_set_relay true
waitMillis 500
pb_set_relay false
}


module 'HTTP server' Comm
author MicroBlocks
version 1 3 
depends WiFi 
tags http network 
description 'Create an HTTP server in MicroBlocks. You can use this library to allow remote control for your Wifi-enabled board.'

  spec 'r' '[net:httpServerGetRequest]' 'HTTP server request : binary data _ : port _' 'bool num' false 8080
  spec 'r' 'request method' 'method of request _' 'str' ''
  spec 'r' 'path of request' 'path of request _' 'str' ''
  spec 'r' 'headers of request' 'headers of request _' 'str' ''
  spec 'r' 'body of request' 'body of request _' 'str' ''
  spec 'r' 'content length of request' 'content length of request _' 'str' ''
  spec ' ' '[net:respondToHttpRequest]' 'respond _ to HTTP request : with body _ : and headers _ : keepAlive _' 'str str str bool' '200 OK' 'Welcome to the MicroBlocks HTTP server' 'Content-Type: text/plain' false
  spec 'r' '_endOfHeaders' '_end of headers _' 'str'
  spec 'r' '_toString' '_toString _' 'auto' 'abc'

to '_endOfHeaders' request {
  return ('[data:find]' ('[data:unicodeString]' ('[data:makeList]' 13 10 13 10)) request)
}

to '_toString' aStringOrByteArray {
  comment 'If argument is a byte array, convert it to a string. '
  if (not (isType aStringOrByteArray 'string')) {
    aStringOrByteArray = ('[data:join]' '' aStringOrByteArray)
  }
  return aStringOrByteArray
}

to 'body of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('[data:copyFromTo]' request (i + 4))
}

to 'content length of request' request {
  local 'i' ('_endOfHeaders' request)
  if (i < 0) {
    return 0
  }
  local 'j' ('[data:find]' 'Content-Length: ' request)
  if (j < 0) {
    comment 'Try alternate capitalization'
    j = ('[data:find]' 'Content-length: ' request)
  }
  if (or (j < 0) (j > i)) {
    return 0
  }
  j += 16
  local 'k' ('[data:find]' ('[data:unicodeString]' 13) request j)
  return (('[data:copyFromTo]' request j (k - 1)) + 0)
}

to 'headers of request' request {
  i = ('_endOfHeaders' request)
  if (i < 0) {
    return ''
  }
  return ('_toString' ('[data:copyFromTo]' request 1 (i - 1)))
}

to 'path of request' request {
  return ('_toString' ('[data:copyFromTo]' request (('[data:find]' ' ' request) + 1) (('[data:find]' ' HTTP' request) - 1)))
}

to 'request method' request {
  return ('_toString' ('[data:copyFromTo]' request 1 (('[data:find]' ' ' request) - 1)))
}


module 'IR Remote' Comm
author MicroBlocks
version 1 2 
tags ir infrared remote 
description 'Sends and receives infrared remote control messages like the ones used for TV sets or air conditioners. Currently supports only the NEC protocol, which is quite common but not the only IR protocol in use. An NEC message consists of a one byte device number and a one byte command. 

Note: Transmitting IR does not work on ESP8266 boards.

Receiving requires an IR receiver module, such as those built into the Circuit Playground Express and ED1 boards. Transmitting requires an IR transmitter LED, such as those built into the Circuit Playground Express and several M5 Stack products. Inexpensive IR LED transmitter and receivers are available for use with other boards.'
variables _ir_pin _ir_pulse_times _ir_transmit_pin 

  spec 'r' 'receiveIR' 'receive IR code'
  spec ' ' 'attachIR' 'attach IR receiver to pin _' 'num' 0
  spec ' ' '_testIR' 'test IR'
  spec 'r' '_receiveIRFromDevice' 'receive IR code from device _' 'num' -1
  spec ' ' '_captureIRMessage' '_captureIRMessage' 'any'
  spec ' ' '_dumpIR' '_dumpIR' 'any'
  spec 'r' '_getIRByte' '_getIRByte _' 'auto any' 4
  spec 'r' '_got32Bits' '_got32Bits' 'any'
  spec ' ' 'IR_Transmit' 'IR transmit device _ command _' 'num num' 48896 1
  spec ' ' '_IR_SendByte' '_IR_SendByte _' 'auto' '10'

to IR_Transmit device command {
  if (_ir_transmit_pin == 0) {if (or ((boardType) == 'CircuitPlayground') ((boardType) == 'M5Atom-Matrix')) {
    _ir_transmit_pin = 12
  } ((boardType) == 'M5StickC') {
    _ir_transmit_pin = 9
  }}
  comment 'Message start pulse and space'
  '[io:playTone]' _ir_transmit_pin 38000
  waitMicros 9000
  '[io:playTone]' _ir_transmit_pin 0
  waitMicros 4500
  comment 'Send device and command and their inverses'
  '_IR_SendByte' (device & 255)
  '_IR_SendByte' ((device >> 8) & 255)
  '_IR_SendByte' command
  '_IR_SendByte' ('~' command)
  comment 'Send stop bit'
  '[io:playTone]' _ir_transmit_pin 38000
  waitMicros 562
  '[io:playTone]' _ir_transmit_pin 0
}

to '_IR_SendByte' byte {
  local 'bit' 1
  repeat 8 {
    if (0 == (byte & bit)) {
      '[io:playTone]' _ir_transmit_pin 38000
      waitMicros 530
      '[io:playTone]' _ir_transmit_pin 0
      waitMicros 530
    } else {
      '[io:playTone]' _ir_transmit_pin 38000
      waitMicros 530
      '[io:playTone]' _ir_transmit_pin 0
      waitMicros 1630
    }
    bit = (bit << 1)
  }
}

to '_captureIRMessage' {
  if (_ir_pulse_times == 0) {
    _ir_pulse_times = (newList 200)
    if (and (_ir_pin == 0) ((boardType) == 'CircuitPlayground')) {
      _ir_pin = 11
    } (and (_ir_pin == 0) ((boardType) == 'Citilab ED1')) {
      _ir_pin = 35
    } (and (_ir_pin == 0) ((boardType) == 'D1-Mini')) {
      _ir_pin = 2
    }
  }
  fillList _ir_pulse_times 0
  local 'i' 1
  comment 'Wait for IR signal -- this is the start of a new message.
Note: THe pin goes low when an IR signal is detected.'
  waitUntil (not (digitalReadOp _ir_pin))
  local 'start' (microsOp)
  forever {
    comment 'Record the time until the end of the current IR pulse ("mark")'
    waitUntil (digitalReadOp _ir_pin)
    local 'end' (microsOp)
    atPut i _ir_pulse_times (end - start)
    i += 1
    start = end
    comment 'Record time until the start of the next IR pulse ("space")'
    repeatUntil (not (digitalReadOp _ir_pin)) {
      if (((microsOp) - start) > 5000) {
        comment 'No IR pulse for 5000 usecs means "end of message"'
        return 0
      }
    }
    local 'end' (microsOp)
    atPut i _ir_pulse_times (end - start)
    i += 1
    start = end
  }
}

to '_dumpIR' {
  comment 'Print raw pulse timings to the terminal.
Can be used to analyze new protocols.'
  local 'i' 1
  printIt '-----'
  repeat (size _ir_pulse_times) {
    local 'mark usecs' (at i _ir_pulse_times)
    local 'space usecs' (at (i + 1) _ir_pulse_times)
    printIt (v 'mark usecs') (v 'space usecs')
    i += 2
    if ((v 'space usecs') == 0) {
      printIt 'timing entries:' (i - 2)
      return 0
    }
  }
}

to '_getIRByte' position {
  local 'result' 0
  local 'i' position
  local 'bit' 1
  repeat 8 {
    if ((at i _ir_pulse_times) > 1000) {result = (result | bit)}
    bit = (bit << 1)
    i += 2
  }
  return result
}

to '_got32Bits' {
  return (and ((at 67 _ir_pulse_times) != 0) ((at 68 _ir_pulse_times) == 0))
}

to '_receiveIRFromDevice' deviceID {
  forever {
    '_captureIRMessage'
    if ('_got32Bits') {
      local 'id' ('_getIRByte' 20 nil)
      if (id == deviceID) {
        return ('_getIRByte' 36 nil)
      }
    }
  }
}

to '_testIR' {
  forever {
    '_captureIRMessage'
    if ('_got32Bits') {
      comment 'Four byte message format:
<device low byte><device high byte><command><command, bit-inverted>'
      local 'b1' ('_getIRByte' 4 nil)
      local 'b2' ('_getIRByte' 20 nil)
      local 'b3' ('_getIRByte' 36 nil)
      local 'b4' ('_getIRByte' 52 nil)
      sayIt 'Device:' ((b2 << 8) | b1) 'code:' b3
    }
  }
}

to attachIR pin {
  _ir_pin = pin
}

to receiveIR {
  forever {
    '_captureIRMessage'
    if ('_got32Bits') {
      return ('_getIRByte' 36 nil)
    }
  }
}


module 'OLED Graphics' Output
author 'Turgut Guneysu'
version 1 12 
choices ModeMenu Horizontal Vertical 
choices OnOffMenu On Off 
choices VideoMenu Inverse Normal 
choices DispTypeMenu 'OLED_0.96in' 'OLED_2.42in' 
description 'Supports 0.96in and 2.42in OLED Displays with SD1306 and SD1309 chipsets. Comm mode is I2C or SPI.
Changes:
- always display buffer
- defer display updates block
- remove reveal
- switch to x (0-127), y (0-63)
- Pruned commands and vars
- textX and textY
- Text at any x and y
- handles newLines
- removed dependencies
- unified data format for chars, sprites, and images
- image draw at any x,y
- filled rectangle
- image draw bug fix
- stack overflow fix
'
variables OLEDReady OLEDi2cAddr _GDBuffer _begCol _begRow _cDecTBL _comma _cTABLE _comMode _dcPin _delayGDUpd _displayType _endCol _endRow _eol _resetPin _textX _textY _dataPrefix _byteCount _imgData _imgWidth _imgHeight 

  spec ' ' 'OLEDInit_I2C' 'initialize i2c _ address(hex) _ reset pin# _ flip _' 'str.DispTypeMenu auto auto bool' 'OLED_0.96in' '3C' '-' false
  spec ' ' 'OLEDInit_SPI' 'initialize spi _ d/c pin# _ reset pin# _ flip _' 'str.DispTypeMenu auto auto bool' 'OLED_2.42in' 16 8 false
  spec ' ' 'OLEDwrite' 'write _ at x _ y _ inverse _' 'auto auto auto bool' 'Hello!' 0 0 false
  spec ' ' 'OLEDshowGDBuffer' 'show display buffer'
  spec ' ' 'OLEDclear' 'clear'
  spec ' ' 'OLEDcontrast' 'set contrast (1-4) _' 'auto' 2
  spec ' ' 'OLEDdrawCircle' 'draw circle at x _ y _ radius _ erase _' 'auto auto auto bool' 64 32 '10' false
  spec ' ' 'OLEDdrawImage' 'draw image _ at x _ y _' 'auto auto auto' 0 0 0
  spec ' ' 'OLEDdrawLine' 'draw line from x _ y _ to x _ y _ erase _' 'auto auto auto auto bool' 0 0 127 63 false
  spec ' ' 'OLEDdrawRect' 'draw rectangle x _ y _ w _ h _ erase _ rounding(3-15) _' 'auto auto auto auto bool auto' 0 0 127 63 false 0
  spec ' ' 'OLEDfillRect' 'fill rectangle x _ y _ w _ h _ erase _' 'auto auto auto auto bool' 20 20 30 20 false
  spec ' ' 'OLEDflip' '_flip display top _' 'bool' false
  spec 'r' 'OLEDmakeImage' 'make image _' 'microbitDisplay' 33084991
  spec ' ' 'OLEDpixel' 'set pixel x _ y _ erase _' 'auto auto bool' 0 0 false
  spec ' ' 'OLEDsetVideo' 'set video _' 'str.VideoMenu' 'Inverse'
  spec 'r' 'OLEDwru' 'cursor location'
  spec ' ' 'defer display updates' 'defer display updates'
  spec ' ' '_GDDRAMoff' '_GDDRAMoff'
  spec ' ' '_GDDRAMon' '_GDDRAMon'
  spec ' ' '_OLEDcursorReset' '_cursor reset'
  spec ' ' '_OLEDsetDisplay' '_set display _' 'str.OnOffMenu' 'On'
  spec ' ' '_OLEDreset' '_set reset Pin# _' 'auto' '0'
  spec ' ' '_SPIWriteCmd' '_SPIWriteCmd'
  spec ' ' '_SPIWriteData' '_SPIWriteData'
  spec ' ' '_T1' '_T1'
  spec ' ' '_T2' '_T2'
  spec ' ' '_T3' '_T3'
  spec 'r' '_cBMP' '_cBMP _ InvYN _' 'auto bool' '' false
  spec ' ' '_clearDisplay' '_clearDisplay'
  spec ' ' '_corner' '_corner _ _ _ _ _' 'auto auto auto auto bool' 'TL' 32 1 0 true
  spec 'r' '_dec2hex' '_dec2hex _' 'auto' 0
  spec ' ' '_initChars' '_initChars'
  spec ' ' '_initCheck' '_initCheck'
  spec ' ' '_initDisplayHW' '_initDisplayHW'
  spec ' ' '_initLibrary' '_initLibrary'
  spec ' ' '_process image data' '_process image data _' 'auto' ' '
  spec ' ' '_sendCmd' '_sendCmd _' 'auto' ''
  spec ' ' '_verifyXY' '_verifyXY _ _' 'auto auto' 0 0

to OLEDInit_I2C dispType i2cAddr resetPin flip {
  comment 'Sets display type and interface and initializes HW settings.
Do NOT set a ResetPin# unless one exists on the display hardware.
NOTE:
Displays supported:
- OLED 0.96in (SD1306 chip) and
- OLED 2.42" (SD1309 chip)
Both displays are 128x64 pixels or 16x8 characters in size.
Displays come in dual mode version (i2c and spi) and pure i2c.
Pure i2c models do not have a Reset pin.

flip setting controls display hardware write direction:
- false: top to bottom
- true: bottom to top'
  _comma = ('[data:unicodeString]' 44)
  _comMode = 'i2c'
  OLEDi2cAddr = (hexToInt ('[data:join]' ('[data:unicodeString]' 32) i2cAddr))
  if (dispType == 'OLED_0.96in') {
    _displayType = 6
    _resetPin = resetPin
  } else {
    _displayType = 9
    _resetPin = resetPin
  }
  '_initDisplayHW'
  if flip {
    OLEDflip true
  }
  '_initLibrary'
  OLEDclear
}

to OLEDInit_SPI dispType dcPin resetPin flip {
  comment 'Sets display type and interface and initializes HW settings.
SPI four wire in Mode-0 is supported. Max speed=10000000.

Do NOT set a ResetPin# unless one exists on the display hardware.
NOTE:
Displays supported:
- OLED 0.96in (SD1306 chip) and
- OLED 2.42" (SD1309 chip)
Both displays are 128x64 pixels or 16x8 characters in size.
Displays come in dual mode version (i2c and spi) and pure i2c.
Pure i2c models do not have a Reset pin.
flip setting controls display hardware write direction:
- false: top to bottom
- true: bottom to top'
  _comma = ('[data:unicodeString]' 44)
  _comMode = 'spi'
  _dcPin = dcPin
  if (dispType == 'OLED_0.96in') {
    _displayType = 6
    _resetPin = resetPin
  } else {
    _displayType = 9
    _resetPin = resetPin
  }
  '[sensors:spiSetup]' 10000000
  '_initDisplayHW'
  if flip {
    OLEDflip true
  }
  '_initLibrary'
  OLEDclear
}

to OLEDclear {
  comment 'Set bounds to FullScreen and CLEARs display
and GDBuffer.'
  _GDBuffer = ('[data:newByteArray]' 1024)
  '_initCheck'
  '_OLEDcursorReset'
  OLEDshowGDBuffer
}

to OLEDcontrast contrast {
  comment 'Sets the brightness control of the display to one of four values.
1 is the least bright, 4 is the brightest setting.'
  '_initCheck'
  local 'cLevels' ('[data:makeList]' 0 '1F' '2F' 'F0')
  if (and (contrast >= 1) (contrast <= 4)) {
    local 'i2cCmd' ('[data:join]' '81' _comma (at contrast cLevels))
    '_sendCmd' i2cCmd
  } else {
    sayIt 'Error in CONTRAST Level'
  }
}

to OLEDdrawCircle cx cy r erase {
  comment 'Bresenham Circle:
Draws circles, even partially bigger than the display.
x: 0-127
y: 0-63
void plotCircle(int xm, int ym, int r)
{
   int x = -r, y = 0, err = 2-2*r; /* II. Quadrant */
   do {
      setPixel(xm-x, ym+y); /*   I. Quadrant */
      setPixel(xm-y, ym-x); /*  II. Quadrant */
      setPixel(xm+x, ym-y); /* III. Quadrant */
      setPixel(xm+y, ym+x); /*  IV. Quadrant */
      r = err;
      if (r <= y) err += ++y*2+1;           /* e_xy+e_y < 0 */
      if (r > x || err > y) err += ++x*2+1; /* e_xy+e_x > 0 or no 2nd y-step */
   } while (x < 0);
}'
  '_initCheck'
  local 'x' (-1 * r)
  local 'y' 0
  local 'err' (2 - (2 * r))
  repeatUntil (x >= 0) {
    OLEDpixel (cx - x) (cy + y) erase
    OLEDpixel (cx - y) (cy - x) erase
    OLEDpixel (cx + x) (cy - y) erase
    OLEDpixel (cx + y) (cy + x) erase
    r = err
    if (r <= y) {
      y += 1
      err = (err + ((y * 2) + 1))
    }
    if (or (r > x) (err > y)) {
      x += 1
      err = (err + ((x * 2) + 1))
    }
  }
  if (not _delayGDUpd) {
    OLEDshowGDBuffer
  }
}

to OLEDdrawImage image x y {
  comment '_imgHeight has to be mod8 or 1-8'
  for row# (maximum 1 ((minimum _imgHeight (64 - y)) / 8)) {
    local 'GDidx' ((((y / 8) * 128) + x) + 1)
    local 'imgDispl' ((row# - 1) * _imgWidth)
    for byte# (minimum _imgWidth (128 - x)) {
      comment 'If y is on page boundary, just copy'
      if (0 == (y % 8)) {
        atPut GDidx _GDBuffer (at (imgDispl + byte#) image)
        GDidx += 1
        if (GDidx > 1024) {
          if (not _delayGDUpd) {OLEDshowGDBuffer}
          return 0
        }
      } else {
        comment 'Else, copy GDLowBits + shiftedByte + GDHiBits to GDBuffer and GDBuffer +128'
        local 'shiftedByte' ('_dec2hex' ((at (imgDispl + byte#) image) << (y % 8)))
        local 'temp' 0
        local 'tempHI' ('[data:copyFromTo]' shiftedByte 1 2)
        local 'tempLO' ('[data:copyFromTo]' shiftedByte 3 4)
        local 'GDLowBits' ((1 << (y % 8)) - 1)
        local 'GDHiBits' (255 - GDLowBits)
        tempLO = ((hexToInt tempLO) | ((at GDidx _GDBuffer) & GDLowBits))
        atPut GDidx _GDBuffer tempLO
        if ((GDidx + 128) <= 1024) {
          tempHI = ((hexToInt tempHI) | ((at (GDidx + 128) _GDBuffer) & GDHiBits))
          atPut (GDidx + 128) _GDBuffer tempHI
        }
        GDidx += 1
        if (GDidx > 1024) {
          if (not _delayGDUpd) {OLEDshowGDBuffer}
          return 0
        }
      }
      waitMillis 0
    }
    y += 8
  }
  if (not _delayGDUpd) {
    OLEDshowGDBuffer
  }
}

to OLEDdrawLine x0 y0 x1 y1 erase {
  comment 'Draws a line from x0,y0 to x1,y1 using the Bresenham Algorithm
x: 0-127
y: 0-63
plotLine(int x0, int y0, int x1, int y1)
    dx =  abs(x1-x0);
    sx = x0<x1 ? 1 : -1;
    dy = -abs(y1-y0);
    sy = y0<y1 ? 1 : -1;
    err = dx+dy;  /* error value e_xy */
    while (true)   /* loop */
        plot(x0, y0);
        if (x0 == x1 && y0 == y1) break;
        e2 = 2*err;
        if (e2 >= dy) /* e_xy+e_x > 0 */
            err += dy;
            x0 += sx;
        end if
        if (e2 <= dx) /* e_xy+e_y < 0 */
            err += dx;
            y0 += sy;
        end if
    end while'
  '_initCheck'
  results = ('[data:makeList]')
  local 'dx' (absoluteValue (x1 - x0))
  local 'dy' (-1 * (absoluteValue (y1 - y0)))
  local 'err' (dx + dy)
  local 'e2' 0
  local 'done' (booleanConstant false)
  if (x0 < x1) {
    local 'sx' 1
  } else {
    local 'sx' -1
  }
  if (y0 < y1) {
    local 'sy' 1
  } else {
    local 'sy' -1
  }
  repeatUntil done {
    OLEDpixel x0 y0 erase
    if (and (x0 == x1) (y0 == y1)) {
      done = (booleanConstant true)
    }
    e2 = (2 * err)
    if (e2 >= dy) {
      err += dy
      x0 += sx
    }
    if (e2 <= dx) {
      err += dx
      y0 += sy
    }
  }
  if (not _delayGDUpd) {
    OLEDshowGDBuffer
  }
}

to OLEDdrawRect TLx TLy width height erase cornerRad {
  comment 'Draw Rectangle with optional rounded corners with radius R.
Does not check for reversed rectangle coordinates for round corners.'
  '_initCheck'
  local 'oldDelayGDUpd' _delayGDUpd
  _delayGDUpd = true
  local 'BRx' (TLx + width)
  local 'BRy' (TLy + height)
  if (cornerRad >= 3) {
    '_corner' 'TL' TLx TLy cornerRad erase
    '_corner' 'TR' BRx TLy cornerRad erase
    '_corner' 'BR' BRx BRy cornerRad erase
    '_corner' 'BL' TLx BRy cornerRad erase
    comment 'TOP - Adjust x'
    OLEDdrawLine (TLx + cornerRad) TLy ((BRx - 1) - cornerRad) TLy erase
    comment 'RIGHT- Adjust y'
    OLEDdrawLine BRx ((TLy + 1) + cornerRad) BRx ((BRy - 1) - cornerRad) erase
    comment 'BOTTOM - Adjust x'
    OLEDdrawLine ((BRx - 1) - cornerRad) BRy ((TLx + 1) + cornerRad) BRy erase
    comment 'LEFT - Adjust y'
    OLEDdrawLine TLx ((BRy - 1) - cornerRad) TLx ((TLy + 1) + cornerRad) erase
  } else {
    OLEDdrawLine TLx TLy BRx TLy erase
    OLEDdrawLine BRx (TLy + 1) BRx BRy erase
    OLEDdrawLine (BRx - 1) BRy TLx BRy erase
    OLEDdrawLine TLx (BRy - 1) TLx (TLy + 1) erase
  }
  _delayGDUpd = oldDelayGDUpd
  if (not _delayGDUpd) {
    OLEDshowGDBuffer
  }
}

to OLEDfillRect x y w h erase {
  for row h {
    for col w {
      OLEDpixel (x + (col - 1)) (y + (row - 1)) erase
    }
  }
  if (not _delayGDUpd) {
    OLEDshowGDBuffer
  }
}

to OLEDflip flip {
  comment 'Flips the display initialization horizontally or vertically.
Horizontal or vertical is based on the pin connector location.'
  if flip {
    '_sendCmd' 'A0,C0'
  } else {
    '_sendCmd' 'A1,C8'
  }
}

to OLEDmakeImage spr# {
  comment 'Receives a spr# representing 5x5 image matrix.
Converts it to a HOR array of 5 VERT bitmap numbers.
This can be displayed with the draw image block.
sprNum max is 33554431'
  '_initCheck'
  local 'spriteList' ('[data:newByteArray]' 5)
  local 'val' 0
  for col 5 {
    for row ('[data:asByteArray]' ('[data:makeList]' 0 5 10 15 20)) {
      local 'bit' (col + row)
      local 'vertBit#' (bit / 5)
      if ((spr# & (1 << (bit - 1))) != 0) {
        if (col != 5) {
          val += (1 << vertBit#)
        } else {
          val += (1 << (vertBit# - 1))
        }
      }
    }
    atPut col spriteList val
    val = 0
  }
  _imgWidth = 5
  _imgHeight = 5
  return spriteList
}

to OLEDpixel x y erase {
  comment 'Places a pixel at x,y in the virtual GDBuffer
Use OLEDshowGDBuffer to display it
1024 Locations
x: 0-127
y: 0-63
page#: 0-7
pagePixel#: 0-7
GDIndex: 1-1024

RangeCheck:
verify x and y are in range of display limits
if X <= num <= Y'
  '_initCheck'
  if (and (and (x >= 0) (x <= 127)) (and (y >= 0) (y <= 63))) {
    local 'page#' (y / 8)
    local 'pagePixel#' (y % 8)
    local 'GDIndex' ((x + ((y / 8) * 128)) + 1)
    local 'byteBMP' (at GDIndex _GDBuffer)
    if (not erase) {
      byteBMP = (byteBMP | (1 << pagePixel#))
    } else {
      comment 'Turn off n th bit'
      byteBMP = (byteBMP & ('~' (1 << pagePixel#)))
    }
    atPut GDIndex _GDBuffer byteBMP
  }
}

to OLEDsetVideo videoMode {
  comment 'Switches the entire display:
Inverse: inverse video mode (bit 0 = on)
Normal: normal video mode (bit 1 = on).
Any image on the display will be preserved when mode changes.'
  '_initCheck'
  if (videoMode == 'Inverse') {
    local 'i2cCmd' 'A7'
  } else {
    local 'i2cCmd' 'A6'
  }
  '_sendCmd' i2cCmd
}

to OLEDshowGDBuffer {
  comment 'Copies contents of virtual _GDBuffer to display
i2c:
   in 61 byte chunks for speed.
   1 byte is used for the command 40
spi:
   fastest is dump buffer
 _GDBuffer is in decimal'
  '_initCheck'
  if (_comMode == 'i2c') {
    local 'idx' 0
    repeat 17 {
      '[sensors:i2cWrite]' OLEDi2cAddr ('[data:join]' _dataPrefix ('[data:copyFromTo]' _GDBuffer idx (idx + 60)))
      idx += 61
    }
  } else {
    '_SPIWriteData'
    '[sensors:spiExchange]' ('[data:copyFromTo]' _GDBuffer 1)
  }
  _delayGDUpd = (booleanConstant false)
}

to OLEDwrite string x y invFlag {
  comment 'Writes strings to display at any x,y; processing CR LF and wrapping at col x.
_textX and _textY are next write locations.'
  '_initCheck'
  local 'oldDelayGDUpd' _delayGDUpd
  _delayGDUpd = true
  '_verifyXY' x y
  local 'origX' x
  if (not (isType string 'string')) {
    string = ('[data:join]' '' string)
  }
  for char string {
    comment 'If in table process it - LINE SET is not supported.'
    if (('[data:find]' char _cTABLE) != -1) {
      OLEDdrawImage ('_cBMP' char invFlag) x y
      x += 8
      if (x > 127) {
        x = origX
        y += 8
        if (y > 63) {
          y = 0
        }
      }
    } (13 == ('[data:unicodeAt]' 1 char)) {
      noop
    } (10 == ('[data:unicodeAt]' 1 char)) {
      x = origX
      y += 8
      if (y > 63) {
        y = 0
      }
    } else {
      comment 'bad char - STOP'
      sayIt 'Invalid CHAR value:' char 'uniCode:' ('[data:unicodeAt]' 1 char)
      stopTask
    }
  }
  _textX = x
  _textY = y
  _delayGDUpd = oldDelayGDUpd
  if (not _delayGDUpd) {
    OLEDshowGDBuffer
  }
}

to OLEDwru {
  comment 'Next Row and Column to print
_textY, _textX'
  return ('[data:asByteArray]' ('[data:makeList]' _textY _textX))
}

to '_GDDRAMoff' {
  comment 'Displays a full empty screen of reverse video.
It disengages the hardware GDBuffer. '
  local 'i2cCmd' 'A5'
  '_sendCmd' i2cCmd
}

to '_GDDRAMon' {
  comment 'It disables the GDDRAMoff mode and engages the hardware GDBuffer for display content.'
  local 'i2cCmd' 'A4'
  '_sendCmd' i2cCmd
}

to '_OLEDcursorReset' {
  comment 'Sets display bounds to full range and resets cursor
to the origin top-left (0,0)
Rows: 0-7
Cols: 0-127
Cursor position is affected by any display operation
and also by OLEDColMode block.'
  '_initCheck'
  local 'cmdString' '22,00,07,21,00,7F'
  '_sendCmd' cmdString
  _textX = 0
  _textY = 0
  _begCol = 0
  _endCol = 127
  _begRow = 0
  _endRow = 7
}

to '_OLEDreset' pin {
  comment 'Does a power off and on on the display,
thus forcing a hardware initialization.'
  digitalWriteOp pin false
  waitMillis 1
  digitalWriteOp pin true
  waitMillis 1
}

to '_OLEDsetDisplay' onoff {
  comment 'Puts the display into
Off:SLEEP   On:WAKE   mode.
Images on display are preserved.'
  '_initCheck'
  if (onoff == 'On') {
    local 'i2cCmd' 'AF'
  } else {
    local 'i2cCmd' 'AE'
  }
  '_sendCmd' i2cCmd
}

to '_SPIWriteCmd' {
  comment 'In SPI mode, we send either a write command
or write data control code. Then follow it with
the appropriate command/data bundle.'
  digitalWriteOp _dcPin false
}

to '_SPIWriteData' {
  comment 'In SPI mode, we send either a write command
or write data control code. Then follow it with
the appropriate command/data bundle.'
  digitalWriteOp _dcPin true
}

to '_T1' {
  comment 'THIN-SS Character Set
Range: space - ?'
  local '_cHEX1' '00000000000000000000005F00000000000007000007000000147F14147F140000242A6B6B2A12000046261008646200304A454D324848000000040300000000001C224100000000000041221C000000082A1C1C1C2A08000008083E080800000000806000000000000808080808080000000060000000000040201008040200003E615149453E000044427F4040000000625151494966000022414949493600101814527F5010000027454545453900003C4A4949493000000301710905030000364949494936000006494949291E00000000660000000000008066000000000008142241000000002424242424240000000041221408000002010151090600'
  local 'idx' 1
  for i 256 {
    atPut i _cDecTBL (hexToInt ('[data:copyFromTo]' _cHEX1 idx (idx + 1)))
    idx += 2
  }
  _cHEX1 = ''
}

to '_T2' {
  comment 'THIN-SS Character Set
Range: @ - _ (underscore)'
  local '_cHEX2' '003E415D55551E00007C121111127C0000417F4949493600001C22414141220000417F4141221C0000417F495D41630000417F491D010300001C224151517200007F080808087F000000417F4100000000304040413F010000417F081422414000417F4140406000007F01020402017F007F010204087F00003E414141413E0000417F4909090600001E212131215E4000417F49192946000026494949493200000301417F410103003F404040403F00000F10204020100F003F40403840403F004122140814224100010244784402010043615149454361007F4141410000000102040810204000004141417F00000008040201020408008080808080808080'
  local 'idx' 1
  for i 256 {
    atPut (256 + i) _cDecTBL (hexToInt ('[data:copyFromTo]' _cHEX2 idx (idx + 1)))
    idx += 2
  }
  _cHEX2 = ''
}

to '_T3' {
  comment 'THIN-SS Character Set
Range: '' - . (last char)'
  local '_cHEX3' '0000000304000000002054545454784000017F304848483000384444444428000030484848317F4000385454545418000000487E490102000098A4A4A4A4780400417F08040478000000447D400000000060808080847D0000017F10284440000000417F40000000007C040478040478007C08040404780000384444444438000084FC98242418000018242498FC840000447C480404180000485454545424000004043F44442000003C404040207C00000C10204020100C003C40403840403C0044281028440000009CA0A0A0A07C00004464544C44000000080836414100000000007700000000000041413608080000020101020201000000000000000000'
  local 'idx' 1
  for i 256 {
    atPut (512 + i) _cDecTBL (hexToInt ('[data:copyFromTo]' _cHEX3 idx (idx + 1)))
    idx += 2
  }
  _cHEX3 = ''
}

to '_cBMP' char invFlag {
  comment 'Returns DEC char bitmap from _cHexTbl and
optionally converts it to inverse (XOR).
Line segments are NOT supported.
A: 00,7c,12,11,12,7c,00
dec:  0,124,18,17,17,124,0
inv:    255,131,237,238,238,131,255'
  local 'key' (((('[data:unicodeAt]' 1 char) - 32) * 8) + 1)
  local 'charList' ('[data:copyFromTo]' _cDecTBL key (key + 7))
  comment 'inverse'
  if invFlag {
    for item# (size charList) {
      atPut item# charList ((at item# charList) ^ 255)
    }
  }
  _imgWidth = 8
  _imgHeight = 8
  return charList
}

to '_clearDisplay' {
  comment 'Clear Screen without initializing _GDBuffer'
  '_initCheck'
  '_OLEDcursorReset'
  local 'clearBuff' ('[data:newByteArray]' 60 0)
  if ('i2c' == _comMode) {
    repeat 17 {
      '[sensors:i2cWrite]' OLEDi2cAddr ('[data:join]' _dataPrefix clearBuff)
    }
    '[sensors:i2cWrite]' OLEDi2cAddr ('[data:join]' _dataPrefix clearBuff)
  } else {
    '_SPIWriteData'
    '[sensors:spiExchange]' ('[data:newByteArray]' 1024)
  }
}

to '_corner' loc cx cy r erase {
  comment 'Calculates and displays the rounded corners for the rectangles.
loc is one of TL, TR, BL, BR ... topLeft, topright, bottomleft, bottomright
cx,cy are the corner coordinates for the rounded corner.
r is the radius in pixels of the arc to be calculated.'
  local 'x' (-1 * r)
  local 'y' 0
  local 'err' (2 - (2 * r))
  if (loc == 'TL') {
    cx += r
    cy += r
  } (loc == 'TR') {
    cx += (-1 * r)
    cy += r
  } (loc == 'BL') {
    cx += r
    cy += (-1 * r)
  } (loc == 'BR') {
    cx += (-1 * r)
    cy += (-1 * r)
  }
  repeatUntil (x >= 0) {
    if (loc == 'TL') {
      OLEDpixel (cx + x) (cy - y) erase
    } (loc == 'TR') {
      OLEDpixel (cx + y) (cy + x) erase
    } (loc == 'BL') {
      OLEDpixel (cx - y) (cy - x) erase
    } (loc == 'BR') {
      OLEDpixel (cx - x) (cy + y) erase
    }
    r = err
    if (r <= y) {
      y += 1
      err = (err + ((y * 2) + 1))
    }
    if (or (r > x) (err > y)) {
      x += 1
      err = (err + ((x * 2) + 1))
    }
  }
}

to '_dec2hex' num {
  comment 'Fast version w/o inversion. (~115uSecs)'
  local '_hexTbl' '0123456789ABCDEF'
  local 'hexNum' ''
  repeatUntil (num < 0) {
    if ((num / 16) != 0) {
      hexNum = ('[data:join]' (at ((num % 16) + 1) _hexTbl) hexNum)
      num = (num / 16)
    } else {
      hexNum = ('[data:join]' (at ((num % 16) + 1) _hexTbl) hexNum)
      num = -1
    }
  }
  comment 'If not half-byte length, pad it.'
  repeatUntil (((size hexNum) % 4) == 0) {
    hexNum = ('[data:join]' '0' hexNum)
  }
  return hexNum
}

to '_initChars' {
  comment 'Creates the character set used in the Library (96 characters)
used JOIN  for SPACE (uni-32) character so it won''t be deleted by mistake.
For each character, _cDecTbl is updated with 8 byte array values.'
  _cTABLE = ('[data:join]' ('[data:unicodeString]' 32) '!"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~.')
  '_T1'
  '_T2'
  '_T3'
}

to '_initCheck' {
  comment 'Verifies Library initialization status.'
  if OLEDReady {
    return 0
  } else {
    sayIt 'Display needs to be initialized before using the library blocks.'
    stopTask
  }
}

to '_initDisplayHW' {
  comment '*** DO NOT CHANGE THESE WITHOUT UNDERSTANDING THEIR MEANINGS ***
*** IT CAN MAKE THE DISPLAY NOT OPERATE CORRECTLY                          ***

Initializes display HW timings
OLED INITIALIZATION STRINGS:
1306: pins are on top
1309: pins are on the right

A8 3F - Multiplex Ratio 0F-3F (16mux to 64mux)
D3 00 - Display Offset (vertical) 00-63
40    - Display Start Line 40-7F (40:0)
A0    - Set Segment Remap A0: Remap 0:0, A1: 127:0                 [A0]
C0    - Scan Direction C0:0-127, C8:127-0                                     [C0]
DA 12 - COM pin hw config 02:double-high 12:normal bits
81 7F - Set contrast 00-FF (00:dimmest, FF:brightest)
A4    - A4:display shows GDRAM, A5:display all ON pixels
A6    - A6:Normal video, A7:Inverse video
D5 F0 - Set display clock HB:OSC freq / LB:divide ratio (00-FF)
D9 22 - Set pre-charge period HB:Phase2 / LB:Phase1 (1-15 DCLK)
DB 20 - Set Vcomh deselect level 20:1306(~0.77xVcc), 34:1309(~0.78xVcc)
8D 14 - Charge Pump Setting 10:disable CP, 14:enable CP
20 00 - Set HORIZONTAL mode
AF    - Display ON/OFF AE:off (sleep mode), AF:on'
  if (_resetPin != '-') {
    '_OLEDreset' _resetPin
  }
  if (9 == _displayType) {
    local 'initCmd' 'A8,3F,D3,00,40,A1,C8,DA,12,81,7F,A4,A6,D5,70,D9,22,DB,34,8D,14,20,00,AF'
  } else {
    local 'initCmd' 'A8,3F,D3,00,40,A1,C8,DA,12,81,7F,A4,A6,D5,70,D9,22,DB,20,8D,14,20,00,AF'
  }
  '_sendCmd' initCmd
}

to '_initLibrary' {
  comment 'Sets all Library variables and initializes the display hardware.
It also initializes the virtual GDBuffer, and clears the display.
NOTE:
Displays supported: OLED1306 (0.96in) and OLED1309 (2.42"), selected via boolean position.
OLED1309 requires the connection of RESET pin to a digital pin.
Both displays are 128x64 pixels or 16x8 characters in size.
Make sure the character hex tables are \n (LF) terminated.
Otherwise, extra lines are added in between and it gets messed up.
eg: A: 00,7C,12,11,11,12,7C,00\n
Max i2c IO is 64 bytes: buffered writes need to be max that size - 16 x 64'
  _comma = ('[data:unicodeString]' 44)
  _eol = ('[data:unicodeString]' 10)
  comment 'Col starts are in HEX'
  _dataPrefix = ('[data:newByteArray]' 1 (hexToInt '40'))
  comment 'There is no FF/255 in th cHexTBL.
this value is used to build the byteArray.'
  _cDecTBL = ('[data:newByteArray]' 768 255)
  _GDBuffer = ('[data:newByteArray]' 1024)
  _textX = 0
  _textY = 0
  _begRow = 0
  _begCol = 0
  _endRow = 7
  _endCol = 127
  _delayGDUpd = (booleanConstant false)
  '_initChars'
  OLEDReady = (booleanConstant true)
  '_OLEDsetDisplay' 'On'
  setUserLED true
  waitMillis 1000
  setUserLED false
}

to '_process image data' image {
  comment 'Processes the new hex image data format.
Each _imgHex gets added to _imgData in DEC byteArray format.
_byteCount keeps track of total bytes processed.
_imgWidth and _imgHeight (mod8) are dimensions.'
  local '_ptr' 1
  comment '_imgData is not initialized yet.'
  if (or (0 == _imgData) (not (isType _imgData 'byte array'))) {
    _imgWidth = (hexToInt ('[data:copyFromTo]' image 1 2))
    _imgHeight = (hexToInt ('[data:copyFromTo]' image 3 4))
    image = ('[data:copyFromTo]' image 5)
    comment 'If _imgHeight is partial byte, adjust to full byte'
    if (not (0 == (_imgHeight % 8))) {
      _imgHeight += (8 - (_imgHeight % 8))
    }
    _imgData = ('[data:newByteArray]' ((_imgWidth * _imgHeight) / 8))
  }
  for byte ((size image) / 2) {
    atPut (_byteCount + byte) _imgData (hexToInt ('[data:copyFromTo]' image _ptr (_ptr + 1)))
    _ptr += 2
  }
  _byteCount += byte
}

to '_sendCmd' cmdString {
  comment 'Input is a comma sep. STRING.
MAKE SURE ALL  INPUT PARAMETERS ARE HEX'
  local '_cList' ('[data:split]' cmdString _comma)
  local 'cmdPrefix' (hexToInt '80')
  if ('i2c' == _comMode) {
    for cmd _cList {
      '[sensors:i2cWrite]' OLEDi2cAddr ('[data:asByteArray]' ('[data:makeList]' cmdPrefix (hexToInt cmd)))
    }
  } else {
    '_SPIWriteCmd'
    for cmd _cList {
      spiSend (hexToInt cmd)
    }
  }
}

to '_verifyXY' x y {
  if (and (and (x >= 0) (x <= 127)) (and (y >= 0) (y <= 63))) {
    return 0
  } else {
    sayIt 'x or y value error:' ('[data:unicodeString]' 10) 'x:' x ' y:' y
    stopTask
  }
}

to 'defer display updates' {
  _delayGDUpd = (booleanConstant true)
}


module PicoBricks
author MicroBlocks
version 2 4 
depends 'Temperature Humidity (DHT11, DHT22)' 
description 'Robotistan PicoBricks Library

This library controls these Pico Bricks components:
- Red LED
- RGB LED
- DC Motors
- Piezo speaker
- Relay Switch (5V-250V, 5A)
- Button
- Potentiometer (variable resistor)
- Light sensor (light dependent resistor)
- Temperature and humidity sensor (DHT11)
- switched to renamed DHT library

Use separate libraries to control:
- Servo motors
- Graphic display (OLED)
- WIFI/Bluetooth expansion board

See https://www.robotistan.com, 
https://wiki.microblocks.fun/boards/pico
'
variables _pb_initialized _pb_pin_RedLED _pb_pin_Button _pb_pin_DHT _pb_pin_Relay _pb_pin_Pot _pb_pin_LDR _pb_pin_Buzzer _pb_pin_Motor1 _pb_pin_Motor2 _pb_pin_RGB_LED _pb_pin_TX _pb_pin_RX _pb_i2c_Addr 

  spec ' ' 'pb_beep' 'PicoBricks beep _ ms' 'auto' 500
  spec 'r' 'pb_button' 'PicoBricks button'
  spec 'r' 'pb_humidity' 'PicoBricks humidity'
  spec 'r' 'pb_light_sensor' 'PicoBricks light sensor (0-100) %'
  spec 'r' 'pb_potentiometer' 'PicoBricks potentiometer'
  spec 'r' 'pb_random_color' 'PicoBricks random color'
  spec 'r' 'pb_rgb_color' 'PicoBricks color r _ g _ b _ (0-255)' 'auto auto auto' 0 0 0
  spec ' ' 'pb_set_motor_speed' 'PicoBricks set motor _ speed _ (0-100)' 'auto num' 1 100
  spec ' ' 'pb_set_red_LED' 'PicoBricks set red LED _' 'bool' true
  spec ' ' 'pb_set_relay' 'PicoBricks set relay _' 'bool' true
  spec ' ' 'pb_set_rgb_color' 'PicoBricks set RGB LED color _' 'color'
  spec 'r' 'pb_temperature' 'PicoBricks temperature (°C)'
  spec ' ' 'pb_turn_off_RGB' 'PicoBricks turn off RGB LED'
  spec ' ' '_pb_init_pins' '_pb_init_pins'

to '_pb_init_pins' {
  if _pb_initialized {return}
  _pb_pin_RGB_LED = 6
  _pb_pin_RedLED = 7
  _pb_pin_Button = 10
  _pb_pin_DHT = 11
  _pb_pin_Relay = 12
  _pb_pin_Buzzer = 20
  _pb_pin_Motor1 = 21
  _pb_pin_Motor2 = 22
  _pb_pin_Pot = 26
  _pb_pin_LDR = 27
  _pb_pin_TX = 0
  _pb_pin_RX = 1
  _pb_i2c_Addr = '3C'
  _pb_initialized = (booleanConstant true)
}

to pb_beep duration {
  '_pb_init_pins'
  local 'end time' ((millisOp) + duration)
  repeatUntil ((millisOp) >= (v 'end time')) {
    digitalWriteOp _pb_pin_Buzzer true
    waitMicros 1900
    digitalWriteOp _pb_pin_Buzzer false
    waitMicros 1900
  }
}

to pb_button {
  '_pb_init_pins'
  return (digitalReadOp _pb_pin_Button)
}

to pb_humidity {
  '_pb_init_pins'
  return (humidity_DHT11 _pb_pin_DHT)
}

to pb_light_sensor {
  comment 'Returns Light Values s a percentage:
0: dark,  100: light'
  '_pb_init_pins'
  return ('[misc:rescale]' (1023 - (analogReadOp _pb_pin_LDR)) 0 1023 0 100)
}

to pb_potentiometer {
  '_pb_init_pins'
  return (analogReadOp _pb_pin_Pot)
}

to pb_random_color {
  local 'n1' (random 100 200)
  local 'n2' (random 0 100)
  if (1 == (random 1 3)) {
    return ((n1 << 16) | (n2 << 8))
  } (1 == (random 1 2)) {
    return ((n2 << 16) | n1)
  } else {
    return ((n1 << 8) | n2)
  }
}

to pb_rgb_color r g b {
  r = (maximum 0 (minimum r 255))
  g = (maximum 0 (minimum g 255))
  b = (maximum 0 (minimum b 255))
  return (((r << 16) | (g << 8)) | b)
}

to pb_set_motor_speed which speed {
  '_pb_init_pins'
  speed = (maximum 0 (minimum speed 100))
  if (which == 1) {
    analogWriteOp _pb_pin_Motor1 ((1023 * speed) / 100)
  } (which == 2) {
    analogWriteOp _pb_pin_Motor2 ((1023 * speed) / 100)
  }
}

to pb_set_red_LED aBoolean {
  '_pb_init_pins'
  digitalWriteOp _pb_pin_RedLED aBoolean
}

to pb_set_relay aBoolean {
  '_pb_init_pins'
  digitalWriteOp _pb_pin_Relay aBoolean
}

to pb_set_rgb_color color {
  '_pb_init_pins'
  '[display:neoPixelSetPin]' _pb_pin_RGB_LED false
  '[display:neoPixelSend]' color
  waitMillis 1
}

to pb_temperature {
  '_pb_init_pins'
  return (temperature_DHT11 _pb_pin_DHT)
}

to pb_turn_off_RGB {
  '_pb_init_pins'
  '[display:neoPixelSetPin]' _pb_pin_RGB_LED false
  '[display:neoPixelSend]' 0
  waitMillis 1
}


module 'Temperature Humidity (DHT11, DHT22)' Input
author MicroBlocks
version 1 2 
tags sensor dht11 dht22 temperature humidity 
description 'Support for the DHT11 and DHT22 environmental sensors. These sensors provide temperature and humidity readings.'
variables _dht_temperature _dht_humidity _dhtData _dhtLastReadTime 

  spec 'r' 'temperature_DHT11' 'temperature (Celsius) DHT11 pin _' 'auto' 4
  spec 'r' 'humidity_DHT11' 'humidity DHT11 pin _' 'auto' 4
  spec 'r' 'temperature_DHT22' 'temperature (Celsius) DHT22 pin _' 'auto' 4
  spec 'r' 'humidity_DHT22' 'humidity DHT22 pin _' 'auto' 4
  spec ' ' '_dhtReadData' '_dhtReadData pin _' 'auto any' 4
  spec 'r' '_dhtChecksumOkay' '_dhtChecksumOkay' 'any'
  spec ' ' '_dhtUpdate' '_dhtUpdate _ isDHT11 _' 'auto bool any' 4 true
  spec 'r' '_dhtReady' '_dhtReady' 'any'

to '_dhtChecksumOkay' {
  if (not (isType _dhtData 'list')) {return (booleanConstant false)}
  local 'checksum' 0
  for i 4 {
    checksum += (at i _dhtData)
  }
  checksum = (checksum & 255)
  return (checksum == (at 5 _dhtData))
}

to '_dhtReadData' pin {
  comment 'Create DHT data array the first time'
  if (_dhtData == 0) {
    _dhtData = (newList 5)
  }
  comment 'fill with 1''s set checksum will be bad if read fails'
  atPut 'all' _dhtData 1
  comment 'Pull pin low for >18msec to request data'
  digitalWriteOp pin false
  waitMillis 20
  local 'useDHTPrimitive' (booleanConstant true)
  if useDHTPrimitive {
    result = ('[sensors:readDHT]' pin)
    if ((booleanConstant false) != result) {
      _dhtData = result
    }
    return 0
  }
  comment 'Read DHT start pulses (H L H L)'
  waitUntil (digitalReadOp pin)
  waitUntil (not (digitalReadOp pin))
  waitUntil (digitalReadOp pin)
  waitUntil (not (digitalReadOp pin))
  local 'i' 1
  local 'byte' 0
  local 'bit' 1
  comment 'Read 40 bits (5 bytes)'
  repeat 40 {
    waitUntil (digitalReadOp pin)
    local 'start' (microsOp)
    waitUntil (not (digitalReadOp pin))
    if (((microsOp) - start) > 40) {
      comment 'Long pulse - append a "1" bit'
      byte += 1
    }
    if (bit == 8) {
      atPut i _dhtData byte
      i += 1
      byte = 0
      bit = 1
    } else {
      byte = (byte << 1)
      bit += 1
    }
    waitUntil (not (digitalReadOp pin))
  }
}

to '_dhtReady' {
  local 'elapsed' ((millisOp) - _dhtLastReadTime)
  return (or (elapsed < 0) (elapsed > 2000))
}

to '_dhtUpdate' pin isDHT11 {
  if ('_dhtReady') {
    _dht_temperature = 0
    _dht_humidity = 0
    '_dhtReadData' pin
    _dhtLastReadTime = (millisOp)
  }
  if ('_dhtChecksumOkay') {
    if isDHT11 {
      _dht_temperature = (at 3 _dhtData)
      _dht_humidity = (at 1 _dhtData)
    } else {
      local 'n' (((at 1 _dhtData) * 256) + (at 2 _dhtData))
      _dht_humidity = ((n + 5) / 10)
      n = ((((at 3 _dhtData) & 127) * 256) + (at 4 _dhtData))
      if (((at 3 _dhtData) & 128) != 0) {
        n = (0 - n)
      }
      _dht_temperature = ((n + 5) / 10)
    }
  }
}

to humidity_DHT11 pin {
  '_dhtUpdate' pin true
  return _dht_humidity
}

to humidity_DHT22 pin {
  '_dhtUpdate' pin false
  return _dht_humidity
}

to temperature_DHT11 pin {
  '_dhtUpdate' pin true
  return _dht_temperature
}

to temperature_DHT22 pin {
  '_dhtUpdate' pin false
  return _dht_temperature
}


module WebThings Comm
author MicroBlocks
version 3 4 
depends 'HTTP server' WiFi 
tags iot webthing wot 
choices thingTypesMenu Alarm BinarySensor ColorControl ColorSensor DoorSensor EnergyMonitor LeakSensor Light Lock MotionSensor MultiLevelSensor MultiLevelSwitch OnOffSwitch PushButton SmartPlug TemperatureSensor Thermostat 
choices thingEventTypesMenu OverheatedEvent PressedEvent DoublePressedEvent LongPressedEvent AlarmEvent 
choices numberPropertyTypesMenu LevelProperty BrightnessProperty ColorTemperatureProperty InstantaneousPowerProperty CurrentProperty VoltageProperty FrequencyProperty TargetTemperatureProperty TemperatureProperty 
choices booleanPropertyTypesMenu BooleanProperty OnOffProperty MotionProperty OpenProperty LeakProperty PushedProperty AlarmProperty 
choices stringPropertyTypesMenu ColorProperty TextProperty HeatingCoolingProperty LockedProperty ThermostatModeProperty 
description 'Create WebThings as specified by the WebThings schema and protocol. If your board is WiFi enabled, you can serve its thing description directly via HTTP. Otherwise, you can enable the MicroBlocks add-on in the WebThings Gateway.
'
variables _WoT_title _WoT_events _WoT_capability _WoT_event_defs _WoT_property_defs '_thing description' 

  spec ' ' 'set thing name to' 'set thing name to _' 'auto' 'MicroBlocks thing'
  spec ' ' 'set thing capability to' 'set thing capability to _' 'str.thingTypesMenu' 'Light'
  spec ' ' 'addBooleanProperty' 'set boolean property _ title _ @Type _ : read only _' 'menu.allVarsMenu str str.booleanPropertyTypesMenu bool' '' '' 'OnOffProperty' false
  spec ' ' 'addStringProperty' 'set string property _ title _ @Type _ : read only _' 'menu.allVarsMenu str str.stringPropertyTypesMenu bool' '' '' 'ColorProperty' false
  spec ' ' 'addNumProp' 'set number property _ title _ min _ max _ @Type _ : read only _' 'menu.allVarsMenu str num num str.numberPropertyTypesMenu bool' '' '' 0 100 'LevelProperty' false
  spec ' ' 'register event' 'register event _ type _' 'auto str.thingEventTypesMenu' 'Button A pressed' 'PressedEvent'
  spec ' ' 'start WebThing server' 'start WebThing server'
  spec ' ' 'trigger event' 'trigger event _' 'auto' 'button pressed'
  spec 'r' 'thing description JSON' 'thing description JSON'
  spec 'r' 'properties JSON' 'properties JSON'
  spec 'r' 'event definitions JSON' 'event definitions JSON'
  spec 'r' 'events JSON' 'events JSON'
  spec ' ' '_process OPTIONS request' '_process OPTIONS request _' 'auto' ''
  spec ' ' '_process PUT request' '_process PUT request _' 'auto' ''
  spec ' ' '_process request' '_process GET request _' 'auto' ''
  spec ' ' '_respond 404 Not Found' '_respond 404 Not Found'
  spec 'r' '_JSON value' '_JSON value _' 'auto' '10'
  spec 'r' '_parse JSON value' '_parse JSON value _' 'auto' ''
  spec 'r' '_trimmed' '_trimmed _' 'auto' '  hello    '
  spec ' ' '_WoT_start_server' '_WoT_start_server'
  spec 'r' '_type of' '_type of _' 'auto' '10'
  spec ' ' '_add or replace property' '_add or replace property _ attributes _' 'menu.nil str' '' ''
  spec ' ' '_clear thing description' '_clear thing description'
  spec 'r' '_varNames' '_varNames'

to '_JSON value' value {
  local 'JSON value' ''
  if (isType value 'string') {
    'JSON value' = ('[data:join]' '"' value '"')
  } (isType value 'list') {
    'JSON value' = '['
    for item value {
      'JSON value' = ('[data:join]' (v 'JSON value') ('_JSON value' item) ',')
    }
    'JSON value' = ('[data:join]' ('[data:copyFromTo]' (v 'JSON value') 1 ((size (v 'JSON value')) - 1)) ']')
  } (isType value 'boolean') {
    if value {
      'JSON value' = 'true'
    } else {
      'JSON value' = 'false'
    }
  } else {
    'JSON value' = value
  }
  return (v 'JSON value')
}

to '_WoT_start_server' {
  local 'request' ''
  forever {
    request = ('[net:httpServerGetRequest]')
    if (request != '') {
      if (('request method' request) == 'GET') {
        '_process request' request
      } (('request method' request) == 'PUT') {
        '_process PUT request' request
      } (('request method' request) == 'OPTIONS') {
        '_process OPTIONS request' request
      } else {
        '_respond 404 Not Found'
      }
    }
    waitMillis 50
  }
}

to '_add or replace property' varName 'attributes JSON' {
  if (_WoT_property_defs == 0) {_WoT_property_defs = ('[data:makeList]')}
  for def _WoT_property_defs {
    if ((at 1 def) == varName) {
      atPut 2 def (v 'attributes JSON')
      return ''
    }
  }
  '[data:addLast]' ('[data:makeList]' varName (v 'attributes JSON')) _WoT_property_defs
}

to '_clear thing description' {
  '_thing description' = 0
}

to '_parse JSON value' JSON {
  local 'value' ('_trimmed' JSON)
  if ((at 1 value) == '[') {
    comment 'Doesn''t handle multi-dimensional lists'
    local 'list' ('[data:makeList]')
    value = ('[data:copyFromTo]' value 2 ((size value) - 1))
    local 'comma index' ('[data:find]' ',' value)
    repeatUntil ((v 'comma index') == -1) {
      '[data:addLast]' ('_parse JSON value' ('[data:copyFromTo]' value 1 ((v 'comma index') - 1))) list
      value = ('[data:copyFromTo]' value ((v 'comma index') + 1))
      'comma index' = ('[data:find]' ',' value)
    }
    '[data:addLast]' ('_parse JSON value' value) list
    value = list
  } else {
    value = ('[misc:jsonGet]' value '')
  }
  return value
}

to '_process OPTIONS request' req {
  local 'path' ('path of request' req)
  '[net:respondToHttpRequest]' '200 OK' '' 'Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: PUT, GET, OPTIONS
Access-Control-Allow-Headers: Content-Type'
}

to '_process PUT request' req {
  local 'path' ('path of request' req)
  if (('[data:find]' '/properties/' path) > 0) {
    local 'varName' ('[data:copyFromTo]' path 13)
    if ('[vars:varExists]' varName) {
      local 'body' ('body of request' req)
      '[vars:setVarNamed]' varName ('_parse JSON value' ('[data:copyFromTo]' body (('[data:find]' ':' body) + 1) (('[data:find]' '}' body) - 1)))
      '[net:respondToHttpRequest]' '200 OK' ('[data:join]' '{"' varName '":' ('_JSON value' ('[vars:varNamed]' varName)) '}') 'Content-Type: application/json'
    } else {
      '_respond 404 Not Found'
    }
  } else {
    '_respond 404 Not Found'
  }
}

to '_process request' req {
  local 'path' ('path of request' req)
  if (path == '/') {
    '[net:respondToHttpRequest]' '200 OK' ('thing description JSON') 'Content-Type: application/json'
  } (or (path == '/properties') (path == '/properties/')) {
    '[net:respondToHttpRequest]' '200 OK' ('properties JSON') 'Content-Type: application/json'
  } (('[data:find]' '/properties/' path) > 0) {
    local 'varName' ('[data:copyFromTo]' path 13)
    if ('[vars:varExists]' varName) {
      '[net:respondToHttpRequest]' '200 OK' ('[data:join]' '{"' varName '":' ('_JSON value' ('[vars:varNamed]' varName)) '}') 'Content-Type: application/json'
    } else {
      '_respond 404 Not Found'
    }
  } (or (path == '/events') (path == '/events/')) {
    '[net:respondToHttpRequest]' '200 OK' ('events JSON') 'Content-Type: application/json'
    _WoT_events = ('[data:makeList]')
  } else {
    '_respond 404 Not Found'
  }
}

to '_respond 404 Not Found' {
  '[net:respondToHttpRequest]' '404 Not Found' '{ "error":"Resource not found" }' 'Content-Type: application/json'
}

to '_trimmed' string {
  comment 'remove surrounding spaces'
  repeatUntil ((at 1 string) != ' ') {
    string = ('[data:copyFromTo]' string 2)
  }
  repeatUntil ((at 'last' string) != ' ') {
    string = ('[data:copyFromTo]' string 1 ((size string) - 1))
  }
  return string
}

to '_type of' value {
  if (isType value 'number') {
    return 'number'
  } (isType value 'list') {
    return 'array'
  } (isType value 'string') {
    return 'string'
  } (isType value 'boolean') {
    return 'boolean'
  }
  comment 'should never happen'
  return 'null'
}

to '_varNames' {
  local 'result' ('[data:makeList]')
  local 'count' ('[vars:varNameForIndex]' -1)
  for i count {
    local 'varName' ('[vars:varNameForIndex]' i)
    if (isType varName 'string') {
      '[data:addLast]' varName result
    }
  }
  return result
}

to addBooleanProperty varName title type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 3) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"boolean","@type":"' type '",' '"readOnly":' readonly)
}

to addNumProp varName title min max type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 5) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"number","@type":"' type '",' '"readOnly":' readonly ',"minimum":' min ',"maximum":' max)
}

to addStringProperty varName title type optionalReadOnly {
  local 'readonly' (booleanConstant false)
  if ((pushArgCount) > 3) {
    readonly = optionalReadOnly
  }
  '_add or replace property' varName ('[data:join]' '"title":"' title '","type":"string","@type":"' type '",' '"readOnly":' readonly)
}

to 'event definitions JSON' {
  local 'JSON' '{'
  if (_WoT_event_defs == 0) {
    _WoT_event_defs = ('[data:makeList]')
  }
  for 'event def' _WoT_event_defs {
    JSON = ('[data:join]' JSON '"' (at 1 (v 'event def')) '":{"description":"MicroBlocks event","@type":"' (at 2 (v 'event def')) '"},')
  }
  if ((size JSON) > 1) {
    return ('[data:join]' ('[data:copyFromTo]' JSON 1 ((size JSON) - 1)) '}')
  } else {
    return '{}'
  }
}

to 'events JSON' {
  local 'JSON' '['
  for event _WoT_events {
    JSON = ('[data:join]' JSON '{"' (at 1 event) '":{"data":{"id":' (at 2 event) '}}},')
  }
  if ((size JSON) > 1) {
    return ('[data:join]' ('[data:copyFromTo]' JSON 1 ((size JSON) - 1)) ']')
  } else {
    return '[]'
  }
}

to 'properties JSON' {
  local 'JSON' '{'
  if (or (_WoT_property_defs == 0) ((size _WoT_property_defs) == 0)) {
    for varName ('_varNames') {
      if (not ((at 1 varName) == '_')) {
        local 'value' ('[vars:varNamed]' varName)
        JSON = ('[data:join]' JSON '"' varName '":{"title":"' varName '","type":"' ('_type of' value) '","links":[{"href":"/properties/' varName '"}],"@type":""},')
      }
    }
  } else {
    for 'property def' _WoT_property_defs {
      local 'varName' (at 1 (v 'property def'))
      JSON = ('[data:join]' JSON '"' varName '":{"links":[{"href":"/properties/' varName '"}],' (at 2 (v 'property def')) '},')
    }
  }
  if ((at 'last' JSON) == ',') {
    JSON = ('[data:copyFromTo]' JSON 1 ((size JSON) - 1))
  }
  return ('[data:join]' JSON '}')
}

to 'register event' 'event title' 'event type' {
  local 'event def' ('[data:makeList]' (v 'event title') (v 'event type'))
  if (_WoT_event_defs == 0) {
    _WoT_event_defs = ('[data:makeList]')
  }
  for def _WoT_event_defs {
    if ((at 1 def) == (v 'event title')) {
      atPut 2 def (v 'event type')
      return ''
    }
  }
  '[data:addLast]' (v 'event def') _WoT_event_defs
}

to 'set thing capability to' capability {
  _WoT_capability = capability
}

to 'set thing name to' title {
  _WoT_title = title
}

to 'start WebThing server' {
  if (_WoT_title == 0) {'set thing name to' 'MicroBlocks thing'}
  if (_WoT_capability == 0) {'set thing capability to' ''}
  if ('[net:hasWiFi]') {
    if (_WoT_events == 0) {_WoT_events = ('[data:makeList]')}
    sendBroadcast '_WoT_start_server'
  } else {
    '_thing description' = ('thing description JSON')
  }
}

to 'thing description JSON' {
  return ('[data:join]' '{"title":"' _WoT_title '","@context":"https://webthings.io/schemas/","@type":["' _WoT_capability '"],"links":[{"rel":"events","href":"/events"},{"rel":"properties","href":"/properties"}],"properties":' ('properties JSON') ',"events":' ('event definitions JSON') '}')
}

to 'trigger event' 'event name' {
  if ('[net:hasWiFi]') {
    '[data:addLast]' ('[data:makeList]' (v 'event name') (millisOp)) _WoT_events
  } else {
    sendBroadcast (v 'event name')
  }
}


module WiFi Comm
author MicroBlocks
version 1 5 
tags communication network 
description 'Connect to a WiFi network. Used in conjunction with other network libraries, such as HTTP client, HTTP server or Web Thing.
'

  spec ' ' 'wifiConnect' 'wifi connect to _ password _ : IP _ gateway _ subnet _' 'str str auto auto auto' 'Network_Name' '' '192.168.1.42' '192.168.1.1' '255.255.255.0'
  spec ' ' 'wifiCreateHotspot' 'wifi create hotspot _ password _' 'str str' 'Network_Name' 'Network_Password'
  spec 'r' 'getIPAddress' 'IP address'
  spec 'r' '[net:myMAC]' 'MAC address'

to getIPAddress {
  return ('[net:myIPAddress]')
}

to wifiConnect ssid password fixedIP gatewayIP subnetIP {
  if (not ('[net:hasWiFi]')) {return}
  '[net:stopWiFi]'
  if ((pushArgCount) < 5) {
    '[net:startWiFi]' ssid password
  } else {
    '[net:startWiFi]' ssid password false fixedIP gatewayIP subnetIP
  }
  local 'startMSecs' (millisOp)
  repeatUntil (('[net:myIPAddress]') != '0.0.0.0') {
    comment 'Timeout after N seconds'
    if (((millisOp) - startMSecs) > 10000) {
      sayIt 'Could not connect'
      return 0
    }
    comment 'Slow blink while trying to connect'
    setUserLED true
    waitMillis 300
    setUserLED false
    waitMillis 300
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

to wifiCreateHotspot ssid password {
  if (not ('[net:hasWiFi]')) {return}
  '[net:startWiFi]' ssid password true
  if ('Connected' != ('[net:wifiStatus]')) {
    sayIt 'Could not create hotspot'
    return 0
  }
  repeat 6 {
    comment 'Quick blinks when connected'
    setUserLED true
    waitMillis 50
    setUserLED false
    waitMillis 50
  }
  sayIt 'My IP address is:' ('[net:myIPAddress]')
}

